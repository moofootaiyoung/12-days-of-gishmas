<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GTA VI: Superior Emulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        .hud-top-right {
            position: absolute;
            top: 20px;
            right: max(20px, env(safe-area-inset-right));
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .money {
            font-size: 28px;
            color: #bfff00;
            font-weight: 800;
            text-shadow: 2px 2px 0 #000, 3px 3px 6px rgba(0,0,0,0.8);
            font-family: 'Pricedown', 'Impact', sans-serif;
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.3) 100%);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .ammo {
            font-size: 22px;
            color: #ffffff;
            font-weight: bold;
            margin-top: 8px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.3) 100%);
            padding: 6px 12px;
            border-radius: 6px;
        }
        .ammo.reloading {
            color: #ff3333;
            animation: flash 0.5s infinite;
        }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .location-tag {
            font-size: 14px;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 8px;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px black;
            background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.5) 20%, rgba(0,0,0,0.5) 80%, transparent 100%);
            padding: 4px 20px;
        }
        .radar-frame {
            position: absolute;
            top: 20px;
            left: max(20px, env(safe-area-inset-left));
            width: 140px;
            height: 140px;
            border: 4px solid rgba(255,255,255,0.9);
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0,0,0,0.7);
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 30px rgba(0,0,0,0.5);
        }
        #radar-canvas { width: 100%; height: 100%; }
        .controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            padding-bottom: env(safe-area-inset-bottom);
        }
        #joystick-zone {
            width: 150px;
            height: 150px;
            pointer-events: auto;
            position: relative;
        }
        
        .joystick-base {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        
        .joystick-stick {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.95) 0%, rgba(200,200,200,0.8) 100%);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5), inset 0 2px 4px rgba(255,255,255,0.5);
            transform: translate(0px, 0px);
            transition: transform 0.1s;
        }
        .joystick-stick.active {
            transition: none;
        }
        #pedals-zone {
            width: 160px;
            height: 150px;
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: flex-end;
            justify-content: flex-end;
        }
        .pedal {
            width: 65px;
            height: 100px;
            border-radius: 12px;
            background: linear-gradient(to bottom, #555, #222);
            border: 3px solid #777;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 22px;
            touch-action: none;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 6px 0 #000, 0 8px 15px rgba(0,0,0,0.4);
        }
        
        .pedal.pressed, .pedal:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #000;
            background: linear-gradient(to bottom, #333, #111);
        }
        .pedal.gas { height: 115px; background: linear-gradient(to bottom, #5cb85c, #2d862d); border-color: #8fd88f; }
        .pedal.brake { height: 85px; background: linear-gradient(to bottom, #d9534f, #a02622); border-color: #e8807d; margin-bottom: 0px; }
        #action-zone {
            position: absolute; 
            bottom: 180px; 
            right: 30px; 
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-end;
        }
        .action-btn {
            width: 65px; height: 65px; 
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 100%);
            border: 3px solid white; 
            border-radius: 50%; 
            display: flex; justify-content: center; align-items: center;
            font-size: 26px; color: white; 
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            transition: transform 0.1s, background 0.1s;
            cursor: pointer;
            pointer-events: auto;
        }
        .action-btn:active, .action-btn.pressed {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.5);
        }
        #btn-fire {
            background: radial-gradient(circle at 30% 30%, rgba(255,80,80,0.6) 0%, rgba(255,50,50,0.3) 100%);
            border-color: #ff5555;
        }
        
        #btn-reload {
            background: radial-gradient(circle at 30% 30%, rgba(80,80,255,0.6) 0%, rgba(50,50,200,0.3) 100%);
            border-color: #5555ff;
            font-size: 26px;
        }
        #btn-mission {
            background: rgba(255, 165, 0, 0.8);
            font-size: 14px;
            font-weight: bold;
            height: 50px;
            width: 100px;
            border-radius: 25px;
            display: none;
        }
        #btn-mission.loading {
            background: rgba(100, 100, 100, 0.7);
        }
        #btn-mission span { font-size: 16px; margin-left: 4px; }
        #mission-overlay, #dialogue-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.92);
            border: 4px solid #ff00cc;
            padding: 25px;
            color: white;
            z-index: 101;
            box-shadow: 0 0 50px rgba(255, 0, 204, 0.6), inset 0 0 30px rgba(255,0,204,0.1);
            border-radius: 15px;
            display: none;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        #dialogue-overlay {
            width: 90%;
            max-width: 500px;
            border-color: #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6), inset 0 0 30px rgba(0,255,255,0.1);
        }
        .dialogue-history {
            height: 200px;
            overflow-y: auto;
            padding: 12px;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
        }
        .dialogue-history p { margin: 8px 0; }
        .dialogue-npc { color: #00ffff; font-weight: bold; }
        .dialogue-player { color: #bfff00; }
        .dialogue-input {
            display: flex;
            gap: 10px;
        }
        .dialogue-input input {
            flex-grow: 1;
            padding: 10px;
            background: #111;
            border: 2px solid #333;
            color: white;
            border-radius: 8px;
        }
        .dialogue-input button {
            padding: 10px 18px;
            background: linear-gradient(180deg, #00ffff 0%, #00cccc 100%);
            color: black;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        .dialogue-close-btn {
            background: linear-gradient(180deg, #f44336 0%, #c62828 100%) !important;
            color: white !important;
        }
        
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #ff0066 0%, #6600ff 50%, #0066ff 100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .title-logo {
            font-family: 'Impact', sans-serif;
            font-size: 18vw;
            color: white;
            text-transform: uppercase;
            font-style: italic;
            text-shadow: 8px 8px 0 rgba(0,0,0,0.3), 0 0 60px rgba(255,255,255,0.5);
            line-height: 0.85;
            letter-spacing: -5px;
        }
        
        .subtitle {
            font-family: 'Brush Script MT', cursive;
            font-size: 10vw;
            color: #ffff00;
            transform: rotate(-5deg) translateY(-25px);
            text-shadow: 3px 3px 0 #ff0066, 0 0 30px rgba(255,255,0,0.5);
        }
        .features {
            margin-top: 25px;
            text-align: center;
            color: rgba(255,255,255,0.95);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            line-height: 1.8;
        }
        .start-btn {
            margin-top: 5px;
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(180deg, #ffffff 0%, #dddddd 100%);
            color: #ff0066;
            border: none;
            border-radius: 50px;
            font-weight: 900;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3), 0 0 40px rgba(255,255,255,0.3);
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.2s, box-shadow 0.2s;
            letter-spacing: 2px;
        }
        .start-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4), 0 0 60px rgba(255,255,255,0.5);
        }
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.5) 100%);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .back-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: white;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <button class="back-btn" onclick="window.parent.postMessage('goBack', '*')">âœ• EXIT</button>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div class="radar-frame">
            <canvas id="radar-canvas" width="150" height="150"></canvas>
        </div>
        <div class="hud-top-right">
            <div class="money" id="money-display">$1,000</div>
            <div class="ammo" id="ammo-display">16 / 16</div>
            <div class="location-tag">Vice Beach</div>
        </div>
        <div class="controls-area">
            <div id="joystick-zone">
                <div class="joystick-base">
                    <div class="joystick-stick" id="stick"></div>
                </div>
            </div>
            
            <div id="action-zone">
                <div id="btn-reload" class="action-btn">R</div>
                <div id="btn-fire" class="action-btn">FIRE</div>
                <div id="btn-action" class="action-btn">E</div>
            </div>
            <div id="pedals-zone">
                <div class="pedal brake" id="btn-brake">S</div>
                <div class="pedal gas" id="btn-gas">W</div>
            </div>
        </div>
    </div>
    <div id="mission-overlay">
        <h3 style="color: #ff00cc; text-align: center; font-size: 24px;">Mission Briefing</h3>
        <p id="mission-text">Loading...</p>
        <button onclick="closeMissionOverlay()" style="padding: 12px; background: linear-gradient(180deg, #0099ff, #0066cc); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">ACCEPT</button>
    </div>
    <div id="dialogue-overlay">
        <h3 id="npc-name" style="color: #00ffff; text-align: center; font-size: 22px;">NPC Dialogue</h3>
        <div class="dialogue-history" id="dialogue-history"></div>
        <div class="dialogue-input">
            <input type="text" id="dialogue-input-field" placeholder="Ask the NPC...">
            <button id="dialogue-send-btn">Send</button>
            <button class="dialogue-close-btn" onclick="closeDialogueOverlay()">Close</button>
        </div>
    </div>
    <div id="start-screen">
        <div class="title-logo">GTA VI</div>
        <div class="subtitle">Superior Edition</div>
        <button class="start-btn" id="play-btn">PLAY</button>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
        import { Water } from 'three/addons/objects/Water.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        
        // --- GEMINI API SETUP ---
        const API_KEY = ""; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        let missionLoading = false;
        let dialogueHistory = [];
        let npcModel;
        let water, sky, sun;
        let composer;
        
        // --- Configuration ---
        const config = {
            shadowMapSize: 1024,
            viewDistance: 400
        };

        // --- HIGH QUALITY TEXTURES ---
        function createDetailedTexture(baseColor, detailColor, type = 'asphalt') {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base gradient
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, baseColor);
            gradient.addColorStop(1, detailColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            if (type === 'asphalt') {
                // Road texture with cracks and wear
                for(let i = 0; i < 15000; i++) {
                    const gray = 30 + Math.random() * 40;
                    ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${0.1 + Math.random() * 0.15})`;
                    ctx.fillRect(Math.random() * size, Math.random() * size, 1 + Math.random() * 3, 1 + Math.random() * 3);
                }
                // Road lines
                ctx.strokeStyle = 'rgba(255, 255, 200, 0.8)';
                ctx.lineWidth = 8;
                ctx.setLineDash([40, 30]);
                ctx.beginPath();
                ctx.moveTo(size/2, 0);
                ctx.lineTo(size/2, size);
                ctx.stroke();
            } else if (type === 'grass') {
                // Detailed grass
                for(let i = 0; i < 20000; i++) {
                    const hue = 80 + Math.random() * 40;
                    const sat = 40 + Math.random() * 30;
                    const light = 25 + Math.random() * 25;
                    ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${0.3 + Math.random() * 0.4})`;
                    ctx.fillRect(Math.random() * size, Math.random() * size, 2 + Math.random() * 4, 2 + Math.random() * 6);
                }
            } else if (type === 'concrete') {
                for(let i = 0; i < 8000; i++) {
                    const gray = 120 + Math.random() * 60;
                    ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${0.08 + Math.random() * 0.1})`;
                    ctx.fillRect(Math.random() * size, Math.random() * size, 2 + Math.random() * 5, 2 + Math.random() * 5);
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        function createNormalMap(intensity = 1) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, size, size);
            
            for(let i = 0; i < 10000; i++) {
                const r = 128 + (Math.random() - 0.5) * 30 * intensity;
                const g = 128 + (Math.random() - 0.5) * 30 * intensity;
                ctx.fillStyle = `rgb(${r}, ${g}, 255)`;
                ctx.globalAlpha = 0.3;
                ctx.fillRect(Math.random() * size, Math.random() * size, 3, 3);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        const asphaltTex = createDetailedTexture('#606060', '#707070', 'asphalt');
        asphaltTex.repeat.set(40, 40);
        const asphaltNormal = createNormalMap(0.5);
        asphaltNormal.repeat.set(40, 40);
        
        const grassTex = createDetailedTexture('#1a4d1a', '#2d662d', 'grass');
        grassTex.repeat.set(30, 30);
        
        const concreteTex = createDetailedTexture('#888888', '#999999', 'concrete');
        concreteTex.repeat.set(20, 20);

        // --- GAME STATE ---
        const gameState = {
            mode: 'driving',
            isPlaying: false,
            velocity: new THREE.Vector3(),
            speed: 0,
            engineForce: 0,
            brakingForce: 0,
            carRotation: 0,
            playerVelocity: new THREE.Vector3(),
            playerRot: 0,
            inputs: { throttle: 0, brake: 0, joyX: 0, joyY: 0, action: false, fire: false },
            buildings: [],
            bullets: [],
            pedestrians: [],
            lastFireTime: 0,
            ammo: 16,
            maxAmmo: 16,
            isReloading: false,
            time: 0
        };

        // --- SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: "high-performance",
            stencil: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Removed bloom for better performance
        // const bloomPass = new UnrealBloomPass(...)
        
        const fxaaPass = new ShaderPass(FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.set(1/window.innerWidth, 1/window.innerHeight);
        composer.addPass(fxaaPass);

        // --- SKY ---
        sky = new Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);

        sun = new THREE.Vector3();
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 2;
        skyUniforms['rayleigh'].value = 1;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;

        const phi = THREE.MathUtils.degToRad(75);
        const theta = THREE.MathUtils.degToRad(180);
        sun.setFromSphericalCoords(1, phi, theta);
        skyUniforms['sunPosition'].value.copy(sun);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x556644, 1.2);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xfffaf0, 3.5);
        sunLight.position.set(200, 350, 150);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = config.shadowMapSize;
        sunLight.shadow.mapSize.height = config.shadowMapSize;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 800;
        const d = 300;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.bias = -0.0003;
        sunLight.shadow.normalBias = 0.02;
        scene.add(sunLight);

        // Ambient fill light
        const ambientLight = new THREE.AmbientLight(0x606080, 0.8);
        scene.add(ambientLight);

        // --- WATER ---
        const waterGeometry = new THREE.PlaneGeometry(4000, 4000);
        water = new Water(waterGeometry, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load(
                'https://threejs.org/examples/textures/waternormals.jpg',
                function(texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }
            ),
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 3.7,
            fog: scene.fog !== undefined
        });
        water.rotation.x = -Math.PI / 2;
        water.position.y = -2;
        scene.add(water);

        // City Ground - High quality
        const islandGeo = new THREE.PlaneGeometry(600, 600, 50, 50);
        const islandMat = new THREE.MeshStandardMaterial({ 
            map: asphaltTex,
            normalMap: asphaltNormal,
            normalScale: new THREE.Vector2(0.3, 0.3),
            roughness: 0.7,
            metalness: 0.05,
            color: 0xbbbbbb
        });
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.rotation.x = -Math.PI / 2;
        island.receiveShadow = true;
        scene.add(island);

        // Grass/Park areas
        const grassGeo = new THREE.PlaneGeometry(620, 620);
        const grassMat = new THREE.MeshStandardMaterial({ 
            map: grassTex,
            roughness: 0.9,
            metalness: 0.0
        });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.15;
        grass.receiveShadow = true;
        scene.add(grass);

        // --- BUILDING MATERIALS ---
        const buildingMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xffe4e1, roughness: 0.3, metalness: 0.1 }), // Pink
            new THREE.MeshStandardMaterial({ color: 0xe0ffff, roughness: 0.2, metalness: 0.2 }), // Cyan
            new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.3, metalness: 0.1 }), // Cream
            new THREE.MeshStandardMaterial({ color: 0xf0fff0, roughness: 0.3, metalness: 0.1 }), // Honeydew
            new THREE.MeshStandardMaterial({ color: 0xfffaf0, roughness: 0.2, metalness: 0.15 }), // Floral White
            new THREE.MeshStandardMaterial({ color: 0xffefd5, roughness: 0.3, metalness: 0.1 }), // Papaya
        ];

        const glassMat = new THREE.MeshPhysicalMaterial({ 
            color: 0x88ccff,
            roughness: 0.0, 
            metalness: 0.9,
            transmission: 0.3,
            thickness: 0.5,
            envMapIntensity: 1.5
        });

        function createBuilding(x, z, w, d, h) {
            const group = new THREE.Group();
            group.position.set(x, h/2, z);

            // Main building
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)].clone();
            
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);

            // Windows - detailed
            const windowRows = Math.floor(h / 5);
            const windowCols = Math.floor(w / 4);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    if (Math.random() > 0.15) {
                        const winGeo = new THREE.BoxGeometry(2.5, 2.5, 0.3);
                        const winMesh = new THREE.Mesh(winGeo, glassMat);
                        winMesh.position.set(
                            (col - windowCols/2 + 0.5) * 4,
                            (row - windowRows/2 + 0.5) * 5,
                            d/2 + 0.1
                        );
                        group.add(winMesh);
                        
                        // Back windows
                        const winMesh2 = winMesh.clone();
                        winMesh2.position.z = -d/2 - 0.1;
                        group.add(winMesh2);
                    }
                }
            }

            // Rooftop details
            if (Math.random() > 0.5) {
                const roofGeo = new THREE.BoxGeometry(w * 0.3, 3, d * 0.3);
                const roofMesh = new THREE.Mesh(roofGeo, mat);
                roofMesh.position.y = h/2 + 1.5;
                roofMesh.castShadow = true;
                group.add(roofMesh);
            }

            // AC units on roof
            for (let i = 0; i < 3; i++) {
                if (Math.random() > 0.4) {
                    const acGeo = new THREE.BoxGeometry(2, 1.5, 2);
                    const acMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7 });
                    const ac = new THREE.Mesh(acGeo, acMat);
                    ac.position.set(
                        (Math.random() - 0.5) * w * 0.6,
                        h/2 + 0.75,
                        (Math.random() - 0.5) * d * 0.6
                    );
                    ac.castShadow = true;
                    group.add(ac);
                }
            }

            scene.add(group);
            
            gameState.buildings.push({
                minX: x - w/2, maxX: x + w/2,
                minZ: z - d/2, maxZ: z + d/2
            });
        }

        // City Generation with better layout
        for(let x = -220; x <= 220; x += 55) {
            for(let z = -220; z <= 220; z += 55) {
                if (Math.abs(x) < 30 && Math.abs(z) < 120) continue;
                
                if (Math.random() > 0.25) {
                    const h = 35 + Math.random() * 100;
                    const w = 30 + Math.random() * 10;
                    createBuilding(x, z, w, w, h);
                } else {
                    createPalm(x + (Math.random() - 0.5) * 20, z + (Math.random() - 0.5) * 20);
                    if (Math.random() > 0.5) {
                        createPalm(x + (Math.random() - 0.5) * 20, z + (Math.random() - 0.5) * 20);
                    }
                }
            }
        }
        
        function createPalm(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // Detailed trunk with segments
            const trunkSegments = 8;
            for (let i = 0; i < trunkSegments; i++) {
                const segGeo = new THREE.CylinderGeometry(
                    0.4 - i * 0.03,
                    0.5 - i * 0.03,
                    2,
                    8
                );
                const segMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const seg = new THREE.Mesh(segGeo, segMat);
                seg.position.y = 1 + i * 1.8;
                seg.rotation.y = i * 0.2;
                seg.castShadow = true;
                group.add(seg);
            }

            // Palm fronds
            const frondMat = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.6,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 8; i++) {
                const frondGeo = new THREE.ConeGeometry(0.8, 6, 4);
                const frond = new THREE.Mesh(frondGeo, frondMat);
                frond.position.y = 15;
                frond.rotation.x = Math.PI * 0.3;
                frond.rotation.y = (i / 8) * Math.PI * 2;
                frond.castShadow = true;
                group.add(frond);
            }

            // Coconuts
            const coconutGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const coconutMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
            for (let i = 0; i < 3; i++) {
                const coconut = new THREE.Mesh(coconutGeo, coconutMat);
                coconut.position.set(
                    Math.cos(i * 2) * 0.5,
                    14,
                    Math.sin(i * 2) * 0.5
                );
                group.add(coconut);
            }

            group.rotation.y = Math.random() * Math.PI;
            scene.add(group);
        }

        // Street lamps
        function createStreetLamp(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 });
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 8, 8), poleMat);
            pole.position.y = 4;
            pole.castShadow = true;
            group.add(pole);

            const arm = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.1), poleMat);
            arm.position.set(1, 8, 0);
            group.add(arm);

            const lampGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const lampMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffaa, 
                emissive: 0xffffaa, 
                emissiveIntensity: 0.5 
            });
            const lamp = new THREE.Mesh(lampGeo, lampMat);
            lamp.position.set(2, 7.8, 0);
            group.add(lamp);

            scene.add(group);
        }

        // Add street lamps
        for (let x = -200; x <= 200; x += 40) {
            createStreetLamp(x, -25);
            createStreetLamp(x, 25);
        }

        // --- PLAYER (Detailed character) ---
        const playerGroup = new THREE.Group();
        playerGroup.visible = false;
        
        const skinTone = 0xffdbac;
        const shirtColor = 0x2196F3; // Blue shirt
        const pantsColor = 0x1a1a2e; // Dark jeans
        const hairColor = 0x2c1810; // Dark brown hair

        // Head
        const headGeo = new THREE.SphereGeometry(0.28, 16, 16);
        const headMat = new THREE.MeshStandardMaterial({ color: skinTone, roughness: 0.7 });
        const pHead = new THREE.Mesh(headGeo, headMat);
        pHead.position.y = 1.7;
        pHead.castShadow = true;
        playerGroup.add(pHead);

        // Hair
        const hairGeo = new THREE.SphereGeometry(0.3, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
        const hairMat = new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.9 });
        const pHair = new THREE.Mesh(hairGeo, hairMat);
        pHair.position.y = 1.78;
        playerGroup.add(pHair);

        // Sunglasses
        const glassesMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
        const pGlasses = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.12), glassesMat);
        pGlasses.position.set(0, 1.72, 0.22);
        playerGroup.add(pGlasses);

        // Torso
        const torsoGeo = new THREE.CylinderGeometry(0.25, 0.28, 0.65, 12);
        const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.6 });
        const pTorso = new THREE.Mesh(torsoGeo, torsoMat);
        pTorso.position.y = 1.2;
        pTorso.castShadow = true;
        playerGroup.add(pTorso);

        // Arms
        const armGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.55, 8);
        const armMat = new THREE.MeshStandardMaterial({ color: skinTone, roughness: 0.7 });
        [-0.35, 0.35].forEach(xOff => {
            const arm = new THREE.Mesh(armGeo, armMat);
            arm.position.set(xOff, 1.1, 0);
            arm.rotation.z = xOff > 0 ? -0.12 : 0.12;
            arm.castShadow = true;
            playerGroup.add(arm);
        });

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.1, 0.11, 0.75, 8);
        const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.8 });
        [-0.14, 0.14].forEach(xOff => {
            const leg = new THREE.Mesh(legGeo, legMat);
            leg.position.set(xOff, 0.5, 0);
            leg.castShadow = true;
            playerGroup.add(leg);
        });

        // Shoes
        const shoeGeo = new THREE.BoxGeometry(0.14, 0.1, 0.25);
        const shoeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }); // White sneakers
        [-0.14, 0.14].forEach(xOff => {
            const shoe = new THREE.Mesh(shoeGeo, shoeMat);
            shoe.position.set(xOff, 0.08, 0.04);
            playerGroup.add(shoe);
        });

        scene.add(playerGroup);

        // --- NPC ---
        npcModel = new THREE.Group();
        const npcBodyMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6600, 
            roughness: 0.4,
            metalness: 0.1
        });
        const npcBody = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.0, 8, 16), npcBodyMat);
        npcBody.position.y = 1.0;
        npcBody.castShadow = true;
        npcModel.add(npcBody);
        
        // NPC marker
        const markerGeo = new THREE.ConeGeometry(0.5, 1, 4);
        const markerMat = new THREE.MeshStandardMaterial({ 
            color: 0x00ff00, 
            emissive: 0x00ff00, 
            emissiveIntensity: 0.5 
        });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.y = 3.5;
        marker.rotation.x = Math.PI;
        npcModel.add(marker);

        npcModel.position.set(Math.random() * 50 - 25, 0, Math.random() * 50 - 25);
        scene.add(npcModel);

        // --- PEDESTRIANS ---
        const pedestrianColors = [
            0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7, 
            0xdfe6e9, 0xfd79a8, 0x6c5ce7, 0x00b894, 0xe17055,
            0x74b9ff, 0xa29bfe, 0xffeaa7, 0x55a3ff, 0xff7675
        ];
        const skinTones = [0xffdbac, 0xf1c27d, 0xe0ac69, 0xc68642, 0x8d5524];
        const hairColors = [0x2c1810, 0x4a3728, 0x090806, 0xb55239, 0xfaf0be];

        function createPedestrian(x, z) {
            const ped = {
                group: new THREE.Group(),
                targetX: x,
                targetZ: z,
                speed: 0.03 + Math.random() * 0.04,
                waitTime: 0,
                direction: Math.random() * Math.PI * 2
            };

            const skinColor = skinTones[Math.floor(Math.random() * skinTones.length)];
            const shirtColor = pedestrianColors[Math.floor(Math.random() * pedestrianColors.length)];
            const pantsColor = Math.random() > 0.5 ? 0x2d3436 : 0x0984e3;
            const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];

            // Head
            const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
            const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.65;
            head.castShadow = true;
            ped.group.add(head);

            // Hair
            const hairGeo = new THREE.SphereGeometry(0.27, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const hairMat = new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.9 });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 1.72;
            ped.group.add(hair);

            // Torso
            const torsoGeo = new THREE.CylinderGeometry(0.22, 0.25, 0.6, 8);
            const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.7 });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 1.2;
            torso.castShadow = true;
            ped.group.add(torso);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.06, 0.07, 0.5, 6);
            const armMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
            [-0.3, 0.3].forEach(xOff => {
                const arm = new THREE.Mesh(armGeo, armMat);
                arm.position.set(xOff, 1.1, 0);
                arm.rotation.z = xOff > 0 ? -0.15 : 0.15;
                arm.castShadow = true;
                ped.group.add(arm);
            });

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08, 0.09, 0.7, 6);
            const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.8 });
            [-0.12, 0.12].forEach(xOff => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(xOff, 0.45, 0);
                leg.castShadow = true;
                ped.group.add(leg);
            });

            // Shoes
            const shoeGeo = new THREE.BoxGeometry(0.12, 0.08, 0.2);
            const shoeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            [-0.12, 0.12].forEach(xOff => {
                const shoe = new THREE.Mesh(shoeGeo, shoeMat);
                shoe.position.set(xOff, 0.06, 0.03);
                ped.group.add(shoe);
            });

            ped.group.position.set(x, 0, z);
            scene.add(ped.group);
            return ped;
        }

        // Spawn pedestrians around the city
        for (let i = 0; i < 25; i++) {
            const x = (Math.random() - 0.5) * 350;
            const z = (Math.random() - 0.5) * 350;
            // Don't spawn inside buildings
            let valid = true;
            for (let b of gameState.buildings) {
                if (x > b.minX - 5 && x < b.maxX + 5 && z > b.minZ - 5 && z < b.maxZ + 5) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                gameState.pedestrians.push(createPedestrian(x, z));
            }
        }

        function updatePedestrians() {
            for (let ped of gameState.pedestrians) {
                if (ped.waitTime > 0) {
                    ped.waitTime -= 0.016;
                    continue;
                }

                // Move towards target
                const dx = ped.targetX - ped.group.position.x;
                const dz = ped.targetZ - ped.group.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 1) {
                    // Pick new random target
                    ped.targetX = ped.group.position.x + (Math.random() - 0.5) * 40;
                    ped.targetZ = ped.group.position.z + (Math.random() - 0.5) * 40;
                    ped.waitTime = Math.random() * 3; // Wait 0-3 seconds
                } else {
                    // Walk towards target
                    const angle = Math.atan2(dx, dz);
                    ped.group.rotation.y = angle;
                    
                    const nextX = ped.group.position.x + Math.sin(angle) * ped.speed;
                    const nextZ = ped.group.position.z + Math.cos(angle) * ped.speed;
                    
                    // Check collision with buildings
                    let blocked = false;
                    for (let b of gameState.buildings) {
                        if (nextX > b.minX - 1 && nextX < b.maxX + 1 && nextZ > b.minZ - 1 && nextZ < b.maxZ + 1) {
                            blocked = true;
                            break;
                        }
                    }
                    
                    if (!blocked && Math.abs(nextX) < 270 && Math.abs(nextZ) < 270) {
                        ped.group.position.x = nextX;
                        ped.group.position.z = nextZ;
                        
                        // Walking animation (bob up and down)
                        ped.group.position.y = Math.sin(gameState.time * 10) * 0.03;
                    } else {
                        // Pick new target if blocked
                        ped.targetX = ped.group.position.x + (Math.random() - 0.5) * 30;
                        ped.targetZ = ped.group.position.z + (Math.random() - 0.5) * 30;
                    }
                }
            }
        }

        // --- CAR (Clean sports car design) ---
        const carGroup = new THREE.Group();
        
        const carPaint = new THREE.MeshStandardMaterial({
            color: 0xff3355,
            metalness: 0.8,
            roughness: 0.2
        });

        const glassMat2 = new THREE.MeshStandardMaterial({ 
            color: 0x4488aa,
            roughness: 0.1, 
            metalness: 0.3,
            transparent: true,
            opacity: 0.7
        });

        // Main body (low sleek shape)
        const bodyGeo = new THREE.BoxGeometry(2.0, 0.5, 4.5);
        const body = new THREE.Mesh(bodyGeo, carPaint);
        body.position.set(0, 0.5, 0);
        body.castShadow = true;
        carGroup.add(body);

        // Hood (front sloped)
        const hoodGeo = new THREE.BoxGeometry(1.8, 0.3, 1.5);
        const hood = new THREE.Mesh(hoodGeo, carPaint);
        hood.position.set(0, 0.55, 1.8);
        hood.castShadow = true;
        carGroup.add(hood);

        // Cabin/roof (low profile)
        const cabinGeo = new THREE.BoxGeometry(1.6, 0.45, 1.8);
        const cabin = new THREE.Mesh(cabinGeo, carPaint);
        cabin.position.set(0, 0.95, -0.2);
        cabin.castShadow = true;
        carGroup.add(cabin);
        
        // Windshield (angled)
        const windshieldGeo = new THREE.BoxGeometry(1.5, 0.4, 0.1);
        const windshield = new THREE.Mesh(windshieldGeo, glassMat2);
        windshield.position.set(0, 0.9, 0.8);
        windshield.rotation.x = -0.4;
        carGroup.add(windshield);

        // Rear window
        const rearWindowGeo = new THREE.BoxGeometry(1.4, 0.35, 0.1);
        const rearWindow = new THREE.Mesh(rearWindowGeo, glassMat2);
        rearWindow.position.set(0, 0.9, -1.1);
        rearWindow.rotation.x = 0.3;
        carGroup.add(rearWindow);

        // Headlights
        const headlightMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffcc, 
            emissiveIntensity: 0.8
        });
        [-0.7, 0.7].forEach(x => {
            const hl = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.12, 0.05), headlightMat);
            hl.position.set(x, 0.55, 2.28);
            carGroup.add(hl);
        });

        // Taillights
        const taillightMat = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            emissive: 0xff0000, 
            emissiveIntensity: 0.6
        });
        [-0.7, 0.7].forEach(x => {
            const tl = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.05), taillightMat);
            tl.position.set(x, 0.55, -2.28);
            carGroup.add(tl);
        });

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
        const tireMat = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.9});
        const rimMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.9, roughness: 0.2});
        const wheels = [];
        
        function addWheel(x, z) {
            const wheelGroup = new THREE.Group();
            const tire = new THREE.Mesh(wheelGeo, tireMat);
            tire.rotation.z = Math.PI/2;
            wheelGroup.add(tire);
            
            const rimGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.26, 12);
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.rotation.z = Math.PI/2;
            wheelGroup.add(rim);
            
            wheelGroup.position.set(x, 0.35, z);
            wheelGroup.castShadow = true;
            carGroup.add(wheelGroup);
            wheels.push(wheelGroup);
        }
        
        addWheel(1.05, 1.5); addWheel(-1.05, 1.5);
        addWheel(1.05, -1.5); addWheel(-1.05, -1.5);

        // Side mirrors
        [-1.05, 1.05].forEach(x => {
            const mirror = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.15), carPaint);
            mirror.position.set(x, 0.85, 0.6);
            carGroup.add(mirror);
        });

        scene.add(carGroup);

        // --- CONTROLS ---
        const stick = document.getElementById('stick');
        const stickZone = document.getElementById('joystick-zone');
        let stickDrag = false;
        let stickStartX = 0, stickStartY = 0;
        stickZone.addEventListener('touchstart', (e) => {
            stickDrag = true;
            stick.classList.add('active');
            const t = e.touches[0];
            stickStartX = t.clientX;
            stickStartY = t.clientY;
            e.preventDefault();
        });
        stickZone.addEventListener('touchmove', (e) => {
            if (!stickDrag) return;
            e.preventDefault();
            const t = e.touches[0];
            let dx = t.clientX - stickStartX;
            let dy = t.clientY - stickStartY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 40;
            if (dist > maxDist) {
                const ratio = maxDist / dist;
                dx *= ratio;
                dy *= ratio;
            }
            stick.style.transform = `translate(${dx}px, ${dy}px)`;
            gameState.inputs.joyX = dx / maxDist;
            gameState.inputs.joyY = dy / maxDist;
        });
        const resetStick = () => {
            stickDrag = false;
            stick.classList.remove('active');
            stick.style.transform = `translate(0px, 0px)`;
            gameState.inputs.joyX = 0;
            gameState.inputs.joyY = 0;
        };
        stickZone.addEventListener('touchend', resetStick);
        stickZone.addEventListener('touchcancel', resetStick);
        const bindBtn = (id, param) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.inputs[param] = 1; el.classList.add('pressed'); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); gameState.inputs[param] = 0; el.classList.remove('pressed'); });
        };
        bindBtn('btn-gas', 'throttle');
        bindBtn('btn-brake', 'brake');
        const btnAction = document.getElementById('btn-action');
        const btnFire = document.getElementById('btn-fire');
        const btnReload = document.getElementById('btn-reload');
        const triggerAction = (e) => { 
            e.preventDefault(); 
            if (gameState.mode === 'walking') {
                checkNPCDialogue();
            } else {
                toggleVehicleEntry(); 
            }
        };
        const triggerFire = (e) => {
            e.preventDefault();
            gameState.inputs.fire = true;
            btnFire.classList.add('pressed');
            setTimeout(() => { 
                gameState.inputs.fire = false;
                btnFire.classList.remove('pressed');
            }, 100);
        };
        const triggerReload = (e) => {
            e.preventDefault();
            reloadWeapon();
            btnReload.classList.add('pressed');
            setTimeout(() => btnReload.classList.remove('pressed'), 200);
        }
        btnAction.addEventListener('touchstart', triggerAction);
        btnAction.addEventListener('click', triggerAction); 
        btnFire.addEventListener('touchstart', triggerFire);
        btnFire.addEventListener('click', triggerFire);
        btnReload.addEventListener('touchstart', triggerReload);
        btnReload.addEventListener('click', triggerReload);
        
        // Mouse click to fire
        document.addEventListener('mousedown', (e) => {
            if (!gameState.isPlaying) return;
            if (e.target.closest('#ui-layer') || e.target.closest('#start-screen')) return;
            gameState.inputs.fire = true;
            btnFire.classList.add('pressed');
        });
        document.addEventListener('mouseup', (e) => {
            gameState.inputs.fire = false;
            btnFire.classList.remove('pressed');
        });
        
        const activeKeys = { w: false, a: false, s: false, d: false, up: false, down: false, left: false, right: false };
        document.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(k === 'w' || k === 'arrowup') activeKeys.w = true;
            if(k === 's' || k === 'arrowdown') activeKeys.s = true;
            if(k === 'a' || k === 'arrowleft') activeKeys.a = true;
            if(k === 'd' || k === 'arrowright') activeKeys.d = true;
            if(k === ' ' ) {
                gameState.inputs.fire = true;
                document.getElementById('btn-fire').classList.add('pressed');
                e.preventDefault();
            }
            if(k === 'r') {
                reloadWeapon();
            }
            if(k === 'f' || k === 'enter') { 
                if (gameState.mode === 'walking') { checkNPCDialogue(); } else { toggleVehicleEntry(); }
                e.preventDefault(); 
            }
            updateInputsFromKeys();
        });
        document.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(k === 'w' || k === 'arrowup') activeKeys.w = false;
            if(k === 's' || k === 'arrowdown') activeKeys.s = false;
            if(k === 'a' || k === 'arrowleft') activeKeys.a = false;
            if(k === 'd' || k === 'arrowright') activeKeys.d = false;
            if(k === ' ') {
                gameState.inputs.fire = false;
                document.getElementById('btn-fire').classList.remove('pressed');
            }
            updateInputsFromKeys();
        });
        function updateInputsFromKeys() {
            const fwd = activeKeys.w || activeKeys.up;
            const back = activeKeys.s || activeKeys.down;
            gameState.inputs.throttle = fwd ? 1 : 0;
            gameState.inputs.brake = back ? 1 : 0;
            if (fwd && !back) gameState.inputs.joyY = -1;
            else if (back && !fwd) gameState.inputs.joyY = 1;
            else gameState.inputs.joyY = 0;
            const left = activeKeys.a || activeKeys.left;
            const right = activeKeys.d || activeKeys.right;
            if (left && !right) {
                gameState.inputs.joyX = -1;
                stick.style.transform = `translate(-30px, 0px)`;
            } else if (right && !left) {
                gameState.inputs.joyX = 1;
                stick.style.transform = `translate(30px, 0px)`;
            } else if (!stickDrag) {
                gameState.inputs.joyX = 0;
                stick.style.transform = `translate(0px, 0px)`;
            }
            document.getElementById('btn-gas').classList.toggle('pressed', gameState.inputs.throttle === 1);
            document.getElementById('btn-brake').classList.toggle('pressed', gameState.inputs.brake === 1);
        }
        async function fetchGeminiResponse(userPrompt, systemPrompt = "") {
            for (let i = 0; i < 3; i++) {
                try {
                    const payload = {
                        contents: [{ parts: [{ text: userPrompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        tools: [{ "google_search": {} }]
                    };
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.status === 429) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: Failed to get response.";
                } catch (error) {
                    console.error("Gemini API call failed:", error);
                    if (i === 2) return "ERROR: Gemini connection failed. Try again later.";
                }
            }
            return "ERROR: Gemini connection failed.";
        }
        function getPlayerLocationDescription() {
            const p = playerGroup.position;
            const x = p.x.toFixed(0);
            const z = p.z.toFixed(0);
            let area = "the inner city streets";
            if (Math.abs(p.x) > 200 || Math.abs(p.z) > 200) area = "the beachfront, near the ocean";
            else if (Math.abs(p.x) < 25 && Math.abs(p.z) < 100) area = "the central park avenue";
            return `Player is currently standing at coordinates (${x}, ${z}) in ${area}.`;
        }
        async function generateMission() {
            if (missionLoading) return;
            const location = getPlayerLocationDescription();
            btnMission.innerHTML = 'Loading...';
            btnMission.classList.add('loading');
            missionLoading = true;
            const systemPrompt = `You are a shady mission giver in a Vice City-inspired game. Invent a single, concise, slightly illegal mission (e.g., fetch, delivery, intimidation) that takes place in the current location. Do NOT use bullet points or lists. The mission must be exactly one paragraph long.`;
            const userPrompt = `Generate a new mission for the player. ${location}`;
            const responseText = await fetchGeminiResponse(userPrompt, systemPrompt);
            document.getElementById('mission-text').innerText = responseText;
            document.getElementById('mission-overlay').style.display = 'flex';
            btnMission.innerHTML = 'âœ¨ NEW MISSION';
            btnMission.classList.remove('loading');
            missionLoading = false;
        }
        window.closeMissionOverlay = function() {
            document.getElementById('mission-overlay').style.display = 'none';
        }
        function renderDialogue() {
            const historyDiv = document.getElementById('dialogue-history');
            historyDiv.innerHTML = '';
            dialogueHistory.forEach(d => {
                const p = document.createElement('p');
                p.className = d.role === 'user' ? 'dialogue-player' : 'dialogue-npc';
                p.innerText = `${d.role === 'user' ? 'YOU' : 'NPC'}: ${d.text}`;
                historyDiv.appendChild(p);
            });
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }
        async function sendDialogue() {
            const inputField = document.getElementById('dialogue-input-field');
            const userText = inputField.value.trim();
            if (!userText) return;
            inputField.value = '';
            dialogueHistory.push({ role: 'user', text: userText });
            renderDialogue();
            const sendBtn = document.getElementById('dialogue-send-btn');
            sendBtn.disabled = true;
            sendBtn.innerText = 'NPC thinking...';
            const location = getPlayerLocationDescription();
            const npcName = "Vito, the old-school Miami enforcer";
            const systemPrompt = `You are an NPC named ${npcName} in a 1980s-inspired Vice City game. You are grumpy but knowledgeable. Your response must be in character, concise (max 3 sentences), and refer to the player's current location if relevant. Do not break character. Do not use markdown formatting.`;
            const conversationHistory = dialogueHistory.map(d => `${d.role}: ${d.text}`).join('\n');
            const userPrompt = `${conversationHistory}\n\n${location}\n\nNPC's reply:`;
            const responseText = await fetchGeminiResponse(userPrompt, systemPrompt);
            dialogueHistory.push({ role: 'npc', text: responseText });
            renderDialogue();
            sendBtn.disabled = false;
            sendBtn.innerText = 'Send';
        }
        function openDialogueOverlay() {
            document.getElementById('npc-name').innerText = "Talk to Vito";
            document.getElementById('dialogue-overlay').style.display = 'flex';
            document.getElementById('dialogue-send-btn').onclick = sendDialogue;
            document.getElementById('dialogue-input-field').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendDialogue();
            });
            if (dialogueHistory.length === 0) {
                dialogueHistory.push({ role: 'npc', text: "What do you want, punk? Don't waste my time, I'm waiting for a delivery." });
                renderDialogue();
            }
        }
        window.closeDialogueOverlay = function() {
            document.getElementById('dialogue-overlay').style.display = 'none';
        }
        function checkNPCDialogue() {
            const dist = playerGroup.position.distanceTo(npcModel.position);
            if (dist < 8.0) {
                openDialogueOverlay();
            } else {
                toggleVehicleEntry();
            }
        }
        function reloadWeapon() {
            if (gameState.isReloading || gameState.ammo === gameState.maxAmmo) return;
            gameState.isReloading = true;
            updateAmmoUI();
            setTimeout(() => {
                gameState.ammo = gameState.maxAmmo;
                gameState.isReloading = false;
                updateAmmoUI();
            }, 1500);
        }
        function updateAmmoUI() {
            const el = document.getElementById('ammo-display');
            if(gameState.isReloading) {
                el.innerText = "RELOADING...";
                el.classList.add('reloading');
            } else {
                el.innerText = `${gameState.ammo} / ${gameState.maxAmmo}`;
                el.classList.remove('reloading');
            }
        }
        function fireWeapon() {
            if (gameState.isReloading || gameState.ammo <= 0) {
                return;
            }
            const now = Date.now();
            if (now - gameState.lastFireTime < 150) return;
            gameState.lastFireTime = now;
            const isCar = gameState.mode === 'driving';
            const source = isCar ? carGroup : playerGroup;
            
            // Glowing bullet
            const bulletGeo = new THREE.SphereGeometry(0.15, 12, 12);
            const bulletMat = new THREE.MeshStandardMaterial({ 
                color: 0xffff00, 
                emissive: 0xffaa00, 
                emissiveIntensity: 2
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            const offset = new THREE.Vector3(0, 1.5, 2); 
            if (isCar) offset.set(0, 1.0, 3);
            const rot = isCar ? gameState.carRotation : playerGroup.rotation.y;
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rot);
            bullet.position.copy(source.position).add(offset);
            const velocity = new THREE.Vector3(Math.sin(rot), 0, Math.cos(rot));
            velocity.multiplyScalar(3.5);
            scene.add(bullet);
            gameState.bullets.push({ mesh: bullet, vel: velocity, life: 120 });
            gameState.ammo--;
            updateAmmoUI();
        }
        function updateBullets() {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const b = gameState.bullets[i];
                b.mesh.position.add(b.vel);
                b.life--;
                if (b.life <= 0) {
                    scene.remove(b.mesh);
                    gameState.bullets.splice(i, 1);
                }
            }
        }
        function checkCollision(x, z) {
            for(let b of gameState.buildings) {
                if(x > b.minX - 1.5 && x < b.maxX + 1.5 && z > b.minZ - 1.5 && z < b.maxZ + 1.5) return true;
            }
            if(Math.abs(x) > 280 || Math.abs(z) > 280) return true;
            return false;
        }
        function toggleVehicleEntry() {
            if (gameState.mode === 'driving') {
                gameState.mode = 'walking';
                const offset = new THREE.Vector3(2.5, 0, 0);
                offset.applyAxisAngle(new THREE.Vector3(0,1,0), gameState.carRotation);
                playerGroup.position.copy(carGroup.position).add(offset);
                playerGroup.position.y = 0;
                playerGroup.visible = true;
                btnAction.innerHTML = 'ðŸš—';
            } else {
                if (playerGroup.position.distanceTo(carGroup.position) < 6) {
                    gameState.mode = 'driving';
                    playerGroup.visible = false;
                    btnAction.innerHTML = 'ðŸšª';
                }
            }
        }
        function updatePhysics() {
            if (!gameState.isPlaying) return;
            if (gameState.inputs.fire) {
                fireWeapon();
            }
            if (gameState.mode === 'driving') {
                const accel = 0.55; 
                const drag = 0.98; 
                const turnSpeed = 0.04; 
                let force = 0;
                if (gameState.inputs.throttle) force += accel;
                if (gameState.inputs.brake) force -= accel * 1.5; 
                const forward = new THREE.Vector3(Math.sin(gameState.carRotation), 0, Math.cos(gameState.carRotation));
                gameState.velocity.add(forward.multiplyScalar(force));
                gameState.velocity.multiplyScalar(drag);
                const speed = gameState.velocity.length();
                if (speed > 0.01) {
                    const dot = gameState.velocity.dot(forward);
                    const dir = dot > 0 ? 1 : -1;
                    gameState.carRotation -= gameState.inputs.joyX * turnSpeed * dir; 
                }
                const idealVel = forward.clone().multiplyScalar(speed);
                gameState.velocity.lerp(idealVel, 0.92);
                const nextX = carGroup.position.x + gameState.velocity.x;
                const nextZ = carGroup.position.z + gameState.velocity.z;
                if (checkCollision(nextX, nextZ)) {
                    gameState.velocity.multiplyScalar(-0.5);
                } else {
                    carGroup.position.x = nextX;
                    carGroup.position.z = nextZ;
                }
                carGroup.rotation.y = gameState.carRotation;
                
                // Wheel rotation animation
                wheels.forEach((w, i) => {
                    if (i < 2) w.rotation.y = gameState.inputs.joyX * 0.4;
                    w.children[0].rotation.x += speed * 0.5;
                });
                
                // Dynamic camera with smooth follow
                const camOffset = new THREE.Vector3(0, 6, -14);
                camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), gameState.carRotation);
                camOffset.add(gameState.velocity.clone().multiplyScalar(-4));
                const target = carGroup.position.clone().add(camOffset);
                camera.position.lerp(target, 0.06);
                camera.lookAt(carGroup.position.clone().add(new THREE.Vector3(0, 1, 0)));
            } else {
                const moveSpeed = 0.6;
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                const camAngle = Math.atan2(camDir.x, camDir.z);
                const jx = gameState.inputs.joyX;
                const jy = gameState.inputs.joyY;
                if (Math.abs(jx) > 0.1 || Math.abs(jy) > 0.1) {
                    const inputAngle = Math.atan2(jx, -jy); 
                    const moveAngle = camAngle + inputAngle;
                    const mx = Math.sin(moveAngle);
                    const mz = Math.cos(moveAngle);
                    const nextX = playerGroup.position.x + mx * moveSpeed;
                    const nextZ = playerGroup.position.z + mz * moveSpeed;
                    if (!checkCollision(nextX, nextZ)) {
                        playerGroup.position.x = nextX;
                        playerGroup.position.z = nextZ;
                    }
                    playerGroup.rotation.y = moveAngle;
                }
                const distToNPC = playerGroup.position.distanceTo(npcModel.position);
                if (distToNPC < 8.0) {
                    btnAction.innerHTML = 'ðŸ’¬ Talk (F)';
                } else {
                    btnAction.innerHTML = 'F / Enter';
                }
                const pPos = playerGroup.position;
                camera.position.lerp(new THREE.Vector3(pPos.x, pPos.y + 10, pPos.z - 12), 0.08);
                camera.lookAt(pPos);
            }
        }
        function updateRadar() {
            const ctx = document.getElementById('radar-canvas').getContext('2d');
            const size = 150;
            const center = size / 2;
            const target = gameState.mode === 'driving' ? carGroup : playerGroup;
            const rot = gameState.mode === 'driving' ? gameState.carRotation : 0;
            
            // Better radar background
            const gradient = ctx.createRadialGradient(center, center, 0, center, center, size/2);
            gradient.addColorStop(0, '#1a2a1a');
            gradient.addColorStop(1, '#0a1a0a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0,size,size);
            
            ctx.save();
            ctx.translate(center, center);
            if(gameState.mode === 'driving') ctx.rotate(rot);
            const px = target.position.x;
            const pz = target.position.z;
            const scale = 0.9;
            
            // Buildings on radar
            ctx.fillStyle = '#446644';
            for(let b of gameState.buildings) {
                const bx = (b.minX - px) * scale;
                const bz = (b.minZ - pz) * scale;
                if(Math.abs(bx)<size && Math.abs(bz)<size) {
                    ctx.fillRect(bx, -bz - (b.maxZ - b.minZ)*scale, (b.maxX-b.minX)*scale, (b.maxZ-b.minZ)*scale);
                }
            }
            
            // NPC blip
            ctx.fillStyle = '#00ffff';
            const nx = (npcModel.position.x - px) * scale;
            const nz = (npcModel.position.z - pz) * scale;
            ctx.beginPath();
            ctx.arc(nx, -nz, 5, 0, Math.PI*2);
            ctx.fill();

            // Pedestrian blips (yellow dots)
            ctx.fillStyle = '#ffff00';
            for (let ped of gameState.pedestrians) {
                const pedX = (ped.group.position.x - px) * scale;
                const pedZ = (ped.group.position.z - pz) * scale;
                if (Math.abs(pedX) < size/2 && Math.abs(pedZ) < size/2) {
                    ctx.beginPath();
                    ctx.arc(pedX, -pedZ, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
            
            // Player blip with glow
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(center, center, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        function animate() {
            requestAnimationFrame(animate);
            gameState.time += 0.016;
            
            updatePhysics();
            if(gameState.isPlaying) {
                updateRadar();
                updateBullets();
                updatePedestrians();
                
                // Animate water
                if (water) {
                    water.material.uniforms['time'].value += 1.0 / 60.0;
                }
                
                // Animate NPC marker
                if (npcModel) {
                    npcModel.children[1].position.y = 3.5 + Math.sin(gameState.time * 3) * 0.3;
                    npcModel.children[1].rotation.y += 0.05;
                }
            }
            
            // Use post-processing
            composer.render();
        }
        document.getElementById('play-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            gameState.isPlaying = true;
        });
        animate();
        camera.position.set(0, 15, -35);
        camera.lookAt(0, 0, 0);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            fxaaPass.material.uniforms['resolution'].value.set(1/window.innerWidth, 1/window.innerHeight);
        });
    </script>
</body>
</html>
